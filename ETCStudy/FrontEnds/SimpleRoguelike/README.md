## Tirano Rush 초기 콘셉트
+ webpack + html, vue, scss만 사용해 텍스트 파일 하나 던져주고 그걸 인터넷되는 환경(cdn)에서 html로 저장하기만 하면 바로 수행할 수 있는 게임을 만드는게 처음 잡은 목표다.. 
+ html 파일 한 개로 컨트롤 필요없는 런타임 10분짜리 커피타임 브레이커를 만든다.
+ 구글의 클릭으로 티라노 점프하는 그 미니게임처럼 우리는 오로지 클릭만으로 간단하게 진행하는 로그라이크를 만들자.
+ 보조 컨셉트는 양산형 가챠게임. 10분짜리로 재미를 끌어올리기 위한 전략이다. 평소에 시놉시스를 잡고 그에 맞게 시스템을 생각했다면 이번엔 시놉시스를 시스템에 맞추자. 가챠로 뭘 뽑아야 가챠만으로도 재미가 있을까?

## 러프한 기획
+ 총 5스테이지.
+ 아주 심플하게 아래와 같은 흐름으로 가자.
1. 메뉴화면에서 start 누르면 인트로 없이 게임이 시작되며 루프 돌입
2. 가챠타임이 오고 가진 자원만큼 가챠를 돌려 리스트가 쭉 나온다. 원하는 캐릭터를 선택하면 자동으로 배치(스테이지만큼의 캐릭터 보유. 1스테이지엔 한 명, 2스테이지엔 두 명 같이.)되고 스테이지 시작
3. 스테이지를 계산해 적정 수준의 몹(스테이지 수만큼)이 등장한다.
4. 그냥 클릭하면 8bit 노이즈와 함께 바로 전투 결과가 바로 나온다. (log 확인 가능)
5. 몹을 쓰러뜨리면 아이템이 세 개 출현하며 이 중 하나를 선택할 수 있다. (선택 가능 수나 루팅 수는 봐가면서 수정)
6. 다음으론 어려운 길, 중간 길, 쉬운 길을 선택할 수 있다. 아이템의 등급은 1~4가 있는 것으로 가정. 어려운 길에서는 확정으로 3등급 이상 아이템이 하나 출현한다. 중간 길에선 보너스 가챠포인트를 준다. 얼추 두 번 진입에 단챠 한 번 정도로. 쉬운 길은 획득 가챠포인트가 줄어들고 2등급 이하 아이템만 출현하는 대신 확정적으로 회복아이템이 나온다.
7. 스테이지에 지정된 횟수를 반복하면 루프 처음의 가챠타임으로.

+ 이런 기획은 보통 게임 자체는 더럽게 재미없기때문에 상황설정으로 상상력을 불어넣어줘야한다. 집중력을 높이는데 좋은건 가챠의 재미를 올려줄 캐릭터, 단지 스텟만 올려주는게 아니라 그럴싸한 설정이 붙은 아이템, 적 몬스터들의 통일된 분위기 등이다. 우린 텍스트로만 만들거니까 뭔가 상상력을 자극하는 문장으로 작명과 설명을 써넣는 것으로 이를 구현한다.... 였는데. 뭔가 기획이 커지고 있다.

## 러프한 구현 이야기
#### framework
+ 각각의 scene을 관리하는 컨트롤러를 둔다. 직관적인 이름이면서도 scene만 관리할 것 같고 그러면서도 가장 상위일 것 같은 이름을 지어야하는데.... 일단 scene controller로 할까.
+ 각 scene는 독자적 루프를 가지며 scene 전환은 call scene method를 통해 이루어진다.
+ scene의 전환에 사용할건 처음써보지만 vue router로... 해볼까. 생각좀 해보자.
+ Scene의 종류와 간략한 기능은 우선 아래와 같음.
    * MainMenu : Clear 또는 Game Over시 여기로 돌아옴. 있는건 Start 버튼 단 하나... 도 아니다. 우리 컨셉질에 충실하게 터치 투 스타트로 가자. 후에 추가된 기획으로 인해 상단에 옵션버튼 추가.
    * Intro Scene : 텍스트가 페이드인 한다. 
    * 가챠 Scene : 가진 자원으로 가챠를 돌림. 가챠 결과에서 원하는 캐릭터를 선택.
    * 전투 Scene : 시작시 적이 나옴. 첫 클릭으로 전투 결과를 로그로 보여줌. 생존시 전투결과를 클릭하면 드랍 아이템이 나오며 아이템 하나 선택(밸런싱적인 부분들 구체적으로 잡히면 조금 수정). 장착할 캐릭터 선택. 완료 후 클릭하면 길 선택(러프한 다음 이벤트 정보 표시). 
    * 이벤트 Scene : 중간길이 이벤트로 대체됐고 유저가 중간길을 골랐을 시 등장. 이벤트 정보를 출력하는 텍스트 창(한 글자씩 초당 30글자 출력 및 클릭으로 한 번에 전체 텍스트 표시)과 선택지가 출력된다.
    * Clear Scene : 게임 클리어 시 출력. Clear 이펙트는 보스 막타시 3초에 걸쳐 게임 화면이 하얀색으로 페이드아웃. 이후 줄 단위 페이드인 하는 텍스트로 짧게 클리거 이후의 상황 나오고 거기서 클릭하면 화면 정 중앙에 Clear! 출력. 클릭 후 다음 화면으로 진행. 1초에 하나씩 클리어 결과들이 출력되고 그 화면에서 클릭하면 Thank you 나오고 끝? 해당 화면에서 클릭하면 메인 메뉴로.
    * Game Over : 게임 오버 시 출력. Game Over 이펙트는 마지막 전투에서 사망시 3초에 걸쳐 게임 화면이 검은색으로 페이드아웃. 이후 한 문장짜리 나름 의미심장해보이는 텍스트 출력 후 클릭하면 Game Over 뜨고 메인 메뉴로 돌아갈 수 있는 버튼 출력.
#### main menu roop
+ main menu는 show main menu라는 method로 부른다. 최초엔 window.onload에서 해당 메서드를 부르며 이후엔 main roop가 clear, 또는 gameover(중도 포기도 gameover)를 인식했을 시 호출한다.
+ Start 버튼만 있으면 됨. 세이브도 없을거고 웹이라 닫을땐 닫기 누르는게 가장 깔끔하거든.... 소리도 안나니 옵션도 필요 없고.

#### main roop
+ 게임 전체를 관리하는 roop에선 각 roop를 호출하고 결과를 받는다.
+ 데이터 모델은 따로 두고 각 roop가 데이터에 직접 개입하는걸로 하자.

#### game frame
+ 언제든지 중도 포기 가능하도록 상단 바에 포기 버튼을 둔다. 컨셉질에 충실하게 버튼 이름은 리세마라. 테스트해서 성능 이슈가 없다면 상단에 Bar를 두고 Vue router로 전투 Scene, 가챠 Scene, 이벤트 Scene을 표현한다.
+ 추가로 텍스트 모드와 게임 모드를 전환하는 버튼도 하나 두자. 진행하다보니 뭔가 꿈이 커지며 당초의 목적을 잊기 시작했다. 그래도 반드시 아무런 CSS 이펙트조차 없는 텍스트 온리(거의 CMD 어드벤쳐? MUD급) 모드는 만드는걸로.

#### 가챠 Scene
+ 입장시 픽업 안내 출력.
+ 기본 화면에는 버튼은 단챠, 5연챠, 진행 버튼 존재. 추가로 현재 선택된 픽을 아이콘으로 출력.
+ 가챠 화면에선 5개의 슬롯에 각각의 캐릭터가 스탠드 이미지로 출력. 슬롯에는 선택 버튼이 있음. 하단에는 현재 선택된 캐릭터 출력. 선택된 캐릭터가 있는 상태에서 다른 캐릭터를 선택하면 변경하시겠습니까? 팝업이 출력. 선택된 캐릭터 없이는 최초 가챠화면으로 돌아가기 위한 다음 버튼이 활성화되지 않는다.
+ 가챠 이펙트는 CSS 공부해보고 재밌게 넣을 수 있음 넣어보자. 좌측부터 순서대로 커튼이 위로 젖혀지는데 등급에 따라 커튼 색이 다르다거나. 근데 이건 커튼 깔끔하게 원하는 위치에서 사라지려면 캔버스 들어가지 않냐 구현에. 일단 봐가면서.
+ 일단 누르고 바로 나오면 시시해지니 누른 다음에도 가챠 결과를 짐작할 수 있는 뭔가가 최소 2초는 나와줘야한다.

## 조금 더 디테일한 기획
#### 캐릭터
+ **등급** : 대세에 맞게 노말, 레어, SR의 세 등급으로 나눈다. 노말은 무난하고, 레어는 노말보다 살짝 성능이 좋다는 느낌이며 SR은 포지션이 확고하게.
+ **직업군** : 3등급 이상 아이템 파밍 노리고 하드만 달리는 유저들을 막기 위해 아이템군을 직업(비스무리한 것. 이건 시놉시스에 따라 달라진다)으로 나눈다. 즉 자기 직업 템만 낄 수 있다. 템파밍을 확실히 견제하면서도 꼬이지 않기 위한 종류 수는 감으로는 5. 봐가면서 수정.
+ **포지션** : 서는 순서는.... 이거도 고민 포인트다. 약간 다키스트 던전같은 느낌의 전투를 원하는데.... 라기보단 다키스트 던전 짭이지. 유저가 스킬 뭐 쓸지 못 고르는 다키스트 던전이요.... 다만 닼던을 보면 UI상 이쁘게 설 수 있는게 최대 4명까지인 것 같은데. 우리는 5명 세울 방법을 고민해야됨.
+ **기본 스텟** : HP, ATK, SPD, GD. 정도로 우선 해볼까.
+ **현재 스텟** : HP를 제외하고는 전투 시작시 기본 스텟을 복사해서 가져온 뒤 아이템 스텟을 더하기 빼기로 적용해 시작값을 정한다. 이후 전투가 진행되며 받은 효과에 따라 유동적으로 변한다. 버프 디버프로 인해 다음 전투까지 이어지는 스텟 변동은 없다. HP는 남아있는 HP로 표기.
+ **아이템 슬롯** : 이 부분은 던전 오브 엔들리스를 따라한다. 다만 설계상 템 루팅이 잦으니 장착 가능한 아이템 수는 1 더해서 3~4개로. 추가로 아래 설명할 스킬풀 시스템으로 인해 종류는 무기, 방어구, 장신구에 추가적으로 스킬획득이 있.. 으면 좋을 것 같다. 유저가 특정 캐릭터에게 템을 몰아주는 전략을 취하지 않았단 전제하에, 한 스테이지에 캐릭터 하나가 **그럭저럭** 템세팅이 완료되는 게 이상적이다.
+ **스킬 풀** : 모든 캐릭터는 스킬 풀에 지정된 순서로 액션을 취하며 다음 취할 액션이 무엇인지는 한 스테이지동안 유지된다. 스테이지가 넘어가면 다음 취할 액션은 초기화된다. 액션풀 스택은 언제든지 추가, 삭제, 특정 위치로 이동이 가능하도록 설계해야한다. 그래야 스턴도 먹이고 필살기 즉발이나 아이템을 통한 추가 스킬 획득 등도 구현할 수 있다. 그리고 깊게 생각할 부분으론 플레이어가 전투의 컨트롤에 개입할 수 있는 유일한 부분이 여기라는 것.... 개입의 방법은 조금 고민해봐야할까. 가급적 게임을 진행하는 Scene에 조작관련 UI를 모두 넣는게 좋지만 스킬풀 조작법에 따라서는 Scene이 좀 더 늘어날 수도 있다.

#### 전투
+ SPD 순서대로 현재 자신의 스킬풀에 있는 스킬중 가장 앞쪽에 있는 스킬을 사용하며 로그를 남겨 진행.

#### 아이템
+ 기본적으로 캐릭터의 스텟 및 스킬 풀, 혹은 파티 전체의 부가효과에 관여한다.
    * **장착 아이템** : 다시 무기, 방어구, 보조, 스킬 추가로 나뉜다. 저 등급 아이템의 의미를 부여하기 위해... 뭔가 수단을 좀 취해보자. 엔들리스에서 느끼던 문제인데 똥템은 집는 입장에서도 재미도 없고 감동도 없으며 나중가선 하등 쓸모도 없다. 단계적으로 밟아나가게 하는 성장요소로 기능하면 좋겠다.
        + 무기 : 심플하게 공격력 상승 및 공격 패시브.
        + 방어구 : 심플하게 HP 상승 및 방어 패시브.
        + 보조 : 패시브 스킬 추가.
        + 스킬 추가 : 보조에 들어갈 법 하지만 캐릭터의 컨셉질을 위해, 그리고 밸런싱을 위해 별도 부위로 둔다.
    * **소비 아이템** : 사실상 회복 아이템 및 버프 아이템이 전부인걸로. 디버프 해제 등은 장기적 디버프가 없을 거라 없다. 플레이어의 의지로 방지할 수 없는 장기적 디버프는 죽으면 끝인 로그라이크에선 짜증만을 부른다. 슬더스는 그걸 알았다. 버프아이템은 플레이어의 몇 안되는 컨트롤 요소이기에 필요하고. 소비성 스킬 추가도 고려는 해보는데... 운용 난이도 상승 및 벨런싱 문제로 안넣는게 나을 듯.
    * **전체 버프 아이템** : 전체 캐릭터의 스텟을 소소하게 올린다. 후반부에 합류한 캐릭터가 노템과 상승한 스테이지 수준으로 인해 바로 넉다운되지 않도록 생각한건데 고려할 게 좀 많은 요소인듯.

#### 스킬
+ 데미지 표시를 할 지 말지를 정하기 위해서 설계부터 Attack 타입과 Active 타입으로 나눌까 생각했지. 근데 모든 스킬이 의미있어보이려면 어떤 스킬이든 기본데미지가 소소하게나마 있는게 낫지 않을까 싶거든. 일단 견제기를 위해 타입은 나누되 스킬은 전부 데미지는 있게 해보자. 프로토타입을 만들어서 해보고 좀 더 생각하죠..
+ 위와 같은 사항을 고려한다면 들어갈 내용은
    * **DMG** : 캐릭터 ATK에 곱해지는 형식으로. 아님 더해지는 형식으로?
    * **부가효과** : function으로 구현할라고.... 하는데 말입니다.
    * **계통** : 단순 공격, 버프, 디버프. 두 개로 우선 하자.
    
#### 이벤트
+ 모든 스테이지는 중간과 최 후반에 부활을 포함하는 회복 이벤트가 반드시 있다. 해당 이벤트는 선택사항이 아니라 필수이기에 갈레길이 출현하지 않도록 할까 생각중. 효율은 고민 좀 해봐야... 

#### 스테이지 설계
+ 가챠게임 모티브니까 가챠게임들의 컨텐츠를 모방하는 식으로 플레이어가 다음 스테이지 환경을 고르는 것도 재밌을 듯. pvp라거나, 이벤트 던전이라거나, 스토리 던전 등등. 콘셉트가 이렇다면 여력에 따라선 스테이지 선택으로 나오는 몹 종류 바뀌는 수준을 넘어서는 환경변화가 있을지도. 
+ 위 컨셉으로 인해 Scene이 늘어나고 작업량이 늘어나더라도 몰입도가 올라간다면 해볼만한 투자다.
+ 스테이지 길이는 얼추... 마지막 합류 캐릭터의 파밍까지 고려하면 10 12 14 16 18 체계가 적당하지 싶은데. 전투도 클릭 한 번으로 끝나니 좀 길다고 런타임이 원래의 콘셉트인 10분을 오버할 것 같지도 않고.
+ 보스는 있는게 좋으려나. 클릭 한 번으로 전투가 끝나기로 했지만 보스전만은 연출을 위해서 한 턴 단위로 턴 돌아가는걸 보여줄까 싶다. 그렇게 하더라도 보스의 어려움같은걸 느끼기엔 시스템이 영 아니니.. 플레이어에게 보스전의 부담을 주기 위해선 보스전의 타격은 운용에 따라 회복 가능하되 누적되는 형태가 좋겠다. 스테이지 클리어 후 회복량에 따라 달라지겠지.

#### 시스템적 콘셉트
+ 기왕 가챠게임인거 랜덤으로 픽업 찬스도 있는걸로. 이 픽업은 그냥 소소한 이벤트성인걸로 할 지 아니면 통제 가능한 운 요소로 할 지, 스테이지 업에 따른 보너스도 있을지 등도 관건. 일단 가챠포인트로 최소한의 가챠만 하고 나머지는 킵할 수 있게 하자. 스테이지당 최소 가챠회수는 5연챠. R 이상 하나 출현 확정이다. 던전 1칸 진행당 2포인트씩 포인트 주고 10포인트로 5연챠.
+ 아이콘... 이쁘게 만들 수 있는지는 재껴두고 캐릭터 전신 이미지는 스탠드, 공격, 승리, 다운 필요. 로그용 아이콘은 공격, 피격, 다운 필요... 아니 근데 텍스트 어드벤쳐도 아니잖아 이래버리면. 근데 그러고싶어. 텍스트 모드로 진행할지 게임모드로 진행할지 선택이라도 가능하게 해볼까. 이래버리면 최고등급인 SR은 가챠 등장 일러스트도 넣고싶은데 거기까진 꿈이 너무 크다....
+ **짚고 넘어갈 게** 이 내용들을 그림없이 텍스트로만 직관적으로 알아보게 하려면 대체 UI 디자인 능력이 얼마나 좋아야되는거야? 물론 애초에 능력 좋은 사람은 텍스트로 이런걸 시도하지 않는다. 멍청하니까 적제적소를 몰라서 텍스트로 이런걸 만들 생각을 하지. 아니 멍청하니까 텍스트로 만들어야한다는 제약을 두고도 이런 기획을 하고있는게 아닐까? 아무튼.... 그래도 일단 해볼래. 짜피 취미로 하는건데...

## 조금 더 디테일한 구현 이야기
#### Player Inputs
+ MainMenu
    * Start Button Click
    * 옵션에서 게임 모드 채크 (디폴트는 텍스트)
+ Intro
    * 진행 버튼
+ 

## 시놉시스
+ 여기까지 구현계획이 잡혔으니 이제서야 이야기할 수 있는 그래서 시놉시스는 무엇인가... 게임 진행방식이 납득이 가되 흥미롭고 멋있고 막 설레고 그래야함.
+ 음... 액자식 구성으로 모종의 이유로 게임을 플레이하는 주인공을 플레이하는게 역시 정석일 것 같긴 한데.... 근데 그냥 세계관 안쪽에서 뛰다니는걸로 하자 이번엔.
+ 아래부분을 계속 진행하다 여기로 돌아왔다. 일단 이게 정해져야 뭐가 더 정해질 것 같다.
+ 사실 안정해지는 이유는 하고싶은게 너무 많아서인데... 기분은 데스티니나 워프레임같은 느낌의 sf 그런거 하고싶지만 또 가챠게임이면 따꾸스러운게 정상적이라....
+ 원래라면 장르에 맞는 배경설정도 중요하다. 미소녀 나와서 아기자기한 파밍 해야겠지만 지금은 우선 하고싶은거로 가자. 어느정도 게임 틀이 다져지면 비슷한 다른거, 다만 미소녀 나오는걸로 갈아탈까.
+ 보더랜드같은 느낌의 그라인딩 RPG다. 당연하지만 세계관이나마 보더랜드의 계보를 잇기로 한 만큼 무기에도 목숨걸어야지.
+ 다만 캐릭터 여러개 다루는 만큼 그에 합당한 설정이 필요하다. 가챠로 캐릭터 데려오는 것도 합당한 설정이 필요하고.
+ 컨셉아트라도 그려야 더 명확해지겠지만... 당장의 칼라 테마는.... 원색보다는 흐린 색 계통의 파랑과 검정이다.
+ 캐릭터들은 메카적인 디자인을 생각하되 디자인 키워드는 우선 마스크로. 센터에 서는 캐릭터는 방독면을 연상케 하는 마스크 디자인.
+ 컨셉을 용병단같은 걸로 할까? 용병들 모집해서 미션에 투입하는 컨셉으로.

## 작업 로그
+ 우선 잘 모르겠으니 vue cli 기본 pkg 구조는 놔두고 그 안에 하위 pkg들을 만들어서 작업하자. 
+ MainMenu.vue 생성. 우선은 Start Button으로 구현. 후에 옵션 버튼 위에 놓고 tuch to start 식으로 변경해야지.
+ Game에 사용되는 컴포넌트들만을 모을 예정인 Game PKG 생성. 이후 Scene에 따라 Battle, Event, Gacha Scene PKG를 만들었으며 각 장면에서 사용하는 컴포넌트는 전부 거기 정의할 것.
+ 게임 진행에 관여하는 Frame PKG를 만들고 GameControllFrame.vue 생성했는데....
+ ......... 라우터 포기. 그래 내가 생각했던건 처음부터 그냥 display none 말고는 방법이 없었던 것 같다.
+ 우선 Gacha scene 레이아웃을 따보자. Flex로다 말이지. 이미지구상은 PPT로 미리 해뒀고.
+ 자 일단 화면은 8:5고. 세로가 5니까 가챠판넬 대 파티판넬 비는 4대 1하면 되겠다. 최외곽 프레임만 크기픽스되면 안에 거는 전부 flex로 비율해주면 될텐데 그게 뜻대로 안되네.
------
#### Intro Scene
+ 지금은 그냥 텍스트 뜨는게 끝... 지금으로써는 몰입도를 높이기는 커녕 오히려 저해한다.
+ 근데 가챠신으로 이어지는게 뭔가 자연스럽게 느껴지게 해야합니다. 하등 필요없지만 로딩이라도 있어야하나.
+ 그렇다고 긴 것도 좀 이상하고 버튼을 누르면 setTimeout해서 화면 바로 안넘어가게 한 다음에 버튼 주변으로 뭔가 이팩트 뜨고 화면 넘어가는게 좋을 것 같은데.
______
#### Status Bar
+ 상단에 자원을 표시하는 스테이터스바를 놓는다.
+ 가챠 자원, 현재 스테이지 몇 스테이지인지... 정도?
------
#### Theme
+ mixin을 제대로 못 쓰니 아직 테마지정이 어글리하다... 이번기회에 어떻게 정리하는게 좋은지 많이 고민해보자.
+ 버튼의 용도를 한 네 가지 정도로 분리해서 비슷한 테마를 사용하도록 한다.
+ UI 색도 가급적 8개 이내에서 전부 사용한다. 옅은 검정, 짙은 파랑, 옅은 파랑, 흰색, 회색, 설명할 때 배경에서 사용할 introsecen 배경색 그거.
------
#### Ghcha Scene
+ 위에서 생각한 대로라면 start 버튼을 누르면 쾅 하는 느낌으로 박력있게 가챠 main이 먼저 나오고 뒤이어 정상 화면이 뜨는 1초짜리 애니메이션이 있는게 좋겠다. 줌아웃으로 가챠창이 들어오게 합시다. 버튼은 타임아웃 이후에 동작하게 하고. 이거 근데 할 능력 되냐? 아무튼.
+ 일단 내부적으로는 GachaPanel과 PartyPanel로 나누었음.
+ 또한 GachaPanel은 main과 result로 Scene을 나눴다.
+ 일단 UI 디자인의 통일성을 위해 버튼 테마는 용도따라서 4개정도 정해놓고 돌려쓰는데 맞는데말이지...
+ 추가로 지금은 그냥 레이아웃 위치잡고있을뿐일지라도 좀 제발.... 
+ 지금 구조에선 어째 2단 프롭 같다. 같은게 아니라 맞네..... 2단만이 아니네요 그리고. 컴포넌트 안에 컴포넌트 안에 컴포넌트 안에 컴포넌트 머 이런식으로 되어있어요.
+ 컴포넌트 안에 컴포넌트를 넣을 때 상위 컴포넌트에서 할 수 있나 고민해보자. 솔직히 Scene에 코드 분리하고 싶은건 사실이라 2단 프롭까지는 참아줄만 하다고 본다.
+ 돈이 읎어서 가챠가 불가능할 시 버튼을 비활성하려 합니다. 이거도 좀 생각하시고.

+ 어디 전역으로 참고할 Data객체가 있었으면 하는데.
+ 플레이어 데이터나 스테이지같은건 어디서든 참조가능해야하니까... 그걸 app이 담당하기에도 솔지기.... 타고가야하는 데이터가 너무 많은데 걍 bus 쓰면 되잖아 잠깐.
+ 생각해보면 이미 구현된 옵저버가 있는데 이게 뭐하는 짓이야 빡통아.
+ 다만... 옵저버 설계를 겁나 잘 해야된다. 나중에 이게 머고 저게 머고 햇갈리지 않도록 수정될지언정 데이터를 한 번 더 철저히 정의하고 인풋 아웃풋을 확실히 정하고 가자. 
------
#### 다시 정의해보는 Scene 진행
+ 우선 좀 적어보자.
+ 좀 진행하면서 슬더스를 따라가서 map은 역시 다 보이는 쪽이 더 낫다고 판단하게 됐다. 스크롤의 제약도 있으니 ftl같은 식으로 그릴 수 있다면 좋겠다. 물론 각 포인트는 어떤 이벤트인지 아이콘을 포함하는 식으로.
+ 원클릭은 아이덴티티이니 가급적 버리면 안된다. 다만, 원클릭으로 전투 결과 뜨기 전에 스킬풀에 개입하거나 아이템을 소비하는 식으로 컨트롤을 하자.
+ 그런 의미에선 결국 버프아이템이 상당히 효용성있어진다. 드랍 아이템 선택의 중요성은 여기서 생긴다고 봐도 되겠지만 드랍 아이템을 하나밖에 못줍는건 비합리적인게 맞다.... 플레이어 컨트롤 요소로 넣을까 했지만... 그냥 드랍제로 가자.
+ 인벤토리... 결국 있어야할 것 같긴 하다. 없게하려면 템세팅 하는 것도 고민좀 해야됨.
    * 인벤토리를 어떤식으로 보게 할 것인가. 최대 이슈사항이다. 게임 진행 중에 아래에 JRPG형 캐릭터 창을 둘까 싶다.
    * 드랍 아이템은 팝업으로 띄워서 클릭으로 주워온다. 인벤토리가 다 찼으면 주워지지 않고 경고팝업이 뜬다.
    * 캐릭터 옆에는 아이템 슬롯이 있다. 해당 슬롯에는 고정형 아이템이 있으며 다키스트 던전처럼 해당 템의 랩을 올리는 식으로 진행해보자. 즉 업그레이드 재료를 주으면 해당 아이템을 클릭하고 캐릭터를 클릭하는 식으로 업그레이드를 할 수 있다.
    * 그렇게 치면 스킬 풀 추가는 없다.
    * 아이템 설명 및 업그레이드에 필요한 아이템은 툴팁으로 간단하게만 표시해준다.
    * 아이템 아래에는 버리기 버튼도 둔다. 해당 버튼을 눌러 언제든지 아이템을 드랍존으로 옮길 수 있으며 드랍존에선 드랍아이템과 마찬가지로 클릭으로 아이템을 회수할 수 있다. 즉 템 버리는건 전투 종료 후.
    * 상단에는 전체 버프 아이템이 표시된다. 이는 슬더스와 비슷한 방식이다.
    * 아이템의 필요수는 올라갔다. 그럼에도 한 전투에 드랍되는 아이템은 많아야 세 개로 제한해야한다. 그것도 종류별로는 한 개씩만. 아이템이 너무 난잡하게 드랍되면 혼란만 부른다.
+ 상점? 상점이 있어야하나? 솔직히 템 중구난방으로 뜨면 유저가 뭐 할 수 있는게 없다.
+ 그리고 사실... 인트로만 빼놓고보면 스테이터스바와 하단 파티 창은 게임 진행동안 항상 있다. 그러네? 그러면 Intro 및 result도 밖에 빼버리면 되지 않나. 이렇게하려면 버스관리가 겁나 빡세지지만.... 그래도 데이터를 직관적으로 보면서 개발할 수 있을 것 같다.
+ 자 일단 해봅시다. Intro를 우선 밖으로 뺀다.
+ 아니 美친 또라이야 파티판넬 구성 바뀌잖아;;; battle로 바꿀까 버튼을? 인벤토리는 어디 두나요 선생님? 병신아. 이 병신아. 인벤토리 근데 진짜 어따두냐 병신아. 스테이터스바 병신아. 눌러서 팝업 띄워 그냥.
+ 아오 골때려. 팝업이면 결과창도 바뀌잖아.... 아니 뭐 누르면 들어가고. 애니메이션 드랍에서 가방으로 날아가는거 작살나는걸로 필요하겠지만. 가방 눌러서 클릭해서 떨구고.. 그럼 되긴 하지. 예상 인풋도 하나 줄어든다.
+ 취소버튼은 인벤토리 옆에 비활성 상태로 있다가 누르면 생기게 하고. 뭐 이럼 일단 해결인가.
+ 아니. 이 Go 버튼을 그래서... 맵에서 뭘로 바꿀건데. 그거 안정해지면 암것도 없다. 맵에는 저런 버튼 아무런 소용이 없음. 맵에서 다음 진행할 방 누르고 고 버튼 누르게 하면 해결은 되지. 게임의 스무스한 흐름이 망가질 뿐. 또 클릭하면 선 색 변하고 타일 하이라이트 되는 그런거도 해야됨. 다시 생각해보면 나쁘진 않은 것 같다. 특히 설계상에서. 
+ 다만 지금 UI는 점점 양산형 가챠게임 컨셉트에서 엇나가고 있다는게 문제지. 느낌을 위해 다음 던전 고르는 창을 하나 만드는 거도.... 나쁘진 않을지 몰라. 좀 고려하자.
------
#### Map
+ 맵의 형태부터 정해야한다.
+ 아까 대충 그려보니 내가 원래 구상하던 거에 선 좀 더 긋는다고 뭐가 더 나아지진 않을 것 같아 보이더라. 다만 슬더스 식 취사선택형 맵은 그대로 갈라고.
+ 최대한 상상력을 자극할 수 있도록 지도의 형태를 보이면서도. 그러면서도 게임 요소로서 재밌어보여야해. 우선 진행 라인 자체의 디자인은 능력되면 전자기판같은 느낌의 디자인은 어떨까. 
+ 각 방이 뭘 의미하는지도 좀 생각해봐야한다. 그래야 지도의 스케일이 정해지고 좀 더 섬세하게 가득찬 느낌의 세계를 구상할 수 있으니까. 이건 세계관과 직결이다.
+ 지금 최대 문제점은 이쁘게 만들려면 한 층당 진행 방 수가 8개가 한계라는거지. 5스테이지까지 있긴 하지만 못해도 70층 구성은 해야된...다. 아마?
+ 스크롤 바 있는 캔버스를 해도 문제인게 버튼하고 캔버스는 따로여.... 
+ **미션식이다.**
+ 왜 이걸 진즉에 생각 못했지.
+ 이거라면 맵상 표시되는 진행 방 수는 6, 7, 7, 8, 9 개까지면 충분하다. 아니 오히려 그 이상이면 난잡하다.
+ 한 방에서 전투 내지는 이벤트, 퍼즐 등을 세 번씩 벌이게 만들어버리면 된다. 방의 구성은 마우스 올리면 팝업으로 뜨는거지.
+ 이거면 그냥 맵 진행이 합리적일 뿐만 아니라.... 신박한데다 UI만 예쁘게 만들면 재밌기까지 하다. 방 하나하나의 의미는 더욱 깊어지고 게임 제작자가 유저에게 내줄 수 있는 숙제도 더 커진다. 뿐만 아니라 이 시스템을 이용하는 룸 패턴도 만들 수 있다.
+ 방 하나하나는 그러니까, 뚫어야하는 하나하나의 기지, 초소, 요세, 포인트인거다. 그걸 뚫는 과정을 전투 세 번 내지는 전투 이벤트 전투 등등으로 세분화 하는거고. 방마다 뚜렷한 개성도 생긴다. 특정 초소가 출현하면 만나게 되는 네임드같은 패턴까지 가능하다 이건. 보상은? 전체아이템이지.
+ 슬더스 장점 융화형 미션식 로그라이크 맵의 라인 생성 
    * 포인트(층)은 스테이지에 따라 6 ~ 8개까지 늘어난다. (보스 포함, 1 = 6/ 2, 3 = 7 / 4, 5 = 8 이 느낌도 나고 공식도 하나로 정리되는듯.)
    * 각 층(수평상태)엔 3~5개의 방이 있다.
    * 윗 층, 아랫층에 상관없이 진행 경로는 방이 더 많은 쪽에서 생성한다.
    * 경로의 수는 방이 더 많은 쪽의 방 수를 n으로 놓으면 n ~ n + 1 이다. 여기서 각 케이스에 대해 경우를 적고 합당한 공식을 유추해보자.
    * n 대 n' 인 경우, n개의 라인을 놓고 random(n)으로 골라진 블록에서 자신의 위치 +- 1로 라인 하나 더 생성.
    * n 대 n'-1 인 경우, rondom(n) 으로 방 하나를 뽑고 나머지 방들로 n'-1과 1 대 1로 이음. 뽑힌 방은 자신의 원래 위치 or 원래 위치 -1에 이음 (이 떄 n이면 원래 위치 -1만 가능). 
    * 이 때 선을 그어선 안되는 위치는. n이 n'과 이어진 경우 n+1과 n-1, n이 n'-1과 이어진 경우 n-1과 n'. 앞에건 2 차이가 나서 이어질 일이 없지만 뒤에건... 한 번에 거르려면 고민 좀 해야한다.
    * n 대 n'-2 인 경우, 는 사실 5 대 3밖에 없다. random(n)을 두 번 돌려 방 두 개를 뽑고 나머지를 1 대 1 매핑한다.
    * 1차 구조. (보스방으로 이어지는 경우는 별도 계산)
    1. 앞의 노드 수, 뒤의 노드 수 n과 m에 대해, n > m을 검사해 검사 function에 큰 쪽 작은 쪽, 어느쪽이 앞쪽인지를 넘긴다. 큰 쪽을 n이라 한다.
    2. n - m 만큼 random으로 n에서 노드를 뽑는다.
    3. 해당 노드를 제외한 노드들을 m에 순서대로 1 대 1 연결한다. 이 때 연결된 선분의 좌표는 앞쪽 노드 객체에 저장.
    * 이후 선을 랜덤으로 생성하며 벡터를 사용한 선분 교차검사를 한다. n이 앞쪽이라면 자기자신의 위 아래, n이 뒤쪽이라면 연결 대상의 위 아래 노드에 저장된 선분만 비교하면 된다.
    4. 우선 첫 랜덤 생성 대상은 뽑힌 n-m의 노드들. 이후 랜덤으로 1 ~ 2개의 노드를 더 선택해서 선분을 랜덤으로 긋고 위 아래와의 중첩여부를 비교한다. 맨 끝 노드들과 중앙 노드들에 적용되는 공식이 달라진다. 또한 같은 선분을 두 번 생성하지 않도록 한다. 이 부분은 유두리있게.
    
+ 슬더스 장점 융화형 미션식 로그라이크 맵의 방 생성
    * 어떤 방이 어느즈음에서 얼마나 나올지가 상당히 중요하다.
    * 중간엔 무조건 힐 지점 하나 넣는다 치고. 문제는 나머지의 배분인데. 일반 요세, 정예 요세, 이벤트 지점 등으로 나눈다 치고. 앞에 뭐가 있느냐에 따라 뒤에 뭐가 있을지의 확률이 좀 달라져야할 것 같음. 막말로 정예 2연타같은건 나오면 안되니까.
    1. 길이가 입력되면 마지막 층을 제외하고 나머지 층에 3~5개의 방 데이터 객체를 생성한다.
    2. type 힐을 우선 밀어넣는다. n/2(올림) 지점이다.
    3. 다음 마지막 1개짜리 노드를 type 보스로 한다.
    4. 여기서 각 포인트를 잇는 메서드를 실행시킨다.
    5. 다음 type 정예를 밀어넣고 정예의 다음 노드가 비어있다면 정예 다음 노드 전용의 확률로 이어진 노드들을 초기화해준다. 힐 5 일반 2 이벤 3.
    6. 나머지 빈 칸에 대해 확률계산을 수행한다. 아마 비율은 이벤트 노드 4 일반노드 4 힐노드 2 정도일 것. 던전 구성상 힐은 온전히 힐이 아니니까 그 정도는 줘도 된다고 생각함. 해보면 또 조정이 필요하겠지만 우선은 그 이상은 뭐 플레이어 운에 맡기자.
+ 요세의 내부젠은 뒷통수 좀 칠 수 있게 규격으로 합시다. 스테이지당 종류별로 규격화된 요세 패턴이 몇 개씩 있으면 예상도 좀 해볼 수 있을거고 머리좀 굴려야할 것.
    
+ 슬더스 장점 융화형 미션식 로그라이크 맵의 드로잉
    * 일단 진행 길이 수 만큼의 화면의 y축의 픽셀을 column으로 나눈다. 최소값, 최대값을 가지고 픽셀 배분하되 보스방의 위치는 픽스다.
    * 각 column의 픽셀을 해당 column에 존재하는 노드 수로 최소값, 최대값을 두고 나눈다. 노드가 존재 가능한 위치를 어느정도 이쁜 선에서 랜덤으로 만들기 위함.
    * 나뉜 칸 안에서 노드의 좌표를 찍는다. 버튼의 라운드를 50%로 두고 보더도 좀 두껍게 둬서 이쁜 원형 버튼으로 만들거임. 중앙 값을 구하고 캔버스에 해당 좌표에서 이어진 노드로 선을 그음.

+ 클릭 동작
    * clickable은 다음 노드 리스트에 존재하는 노드들로 한정된다. 나머지는 그냥 눌러도 아무 표시도 되지 않는다.
    * 다음 노드의 배열상 좌표를 가지고 해당 노드의 clickable을 true로 한다. 다음 노드가 선택되면.... 현재 노드에 다음 노드가 선택되었음을 인식시켜야 선을 긋는다...
    * 생성된 line의 데이터는 전 노드가 들고있다. 클릭 가능한 노드가 클릭될 시, 우선 가진 선 중에 기존 붉은 선이 있다면 검은색으로 바로 바꾸고 새로 들어온 좌표까지 붉은 선을 쭉 그어준다. 이게 데이터를 얼마나 먹는질 모르겠네.
    * Dive 이후엔 한 번 표시된 붉은 선의 데이터는 리프래시 하지 말자. 지금까지의 경로를 보여주는거도 나쁘진 않을 것 같거든.

+ 대충 단순 맵에 필요한 데이터를 정리하자면....
    1. 각 row의 데이터 길이가 다른 방 데이터 2차원 배열이 있다.
    2. 방 데이터는 다음의 데이터를 가지고 있다. 이어지는 노드의 배열상 좌표, 내 좌표 x, y. 선택된  다음 노드(기본 null 상태. null 검사 가능하니까 이게 또 좋네). 자신의 구조.
    3. 층수는 GameData가 들고있다는다. 유저의 위치는... 게임 객체가 들고있어야 할 것 같기도 하고 맵 객체가 들고있어야할 것 같기도 하고.. 유저 객체가 들고있는게 맞을듯. 유저의 좌표니까.

+ 맵 계획은 완료.
+ 문제는 컴포넌트에 개입하는 과정이 데이터 저장과 vue에서 이를 해석하는 과정을 통해 이루어져야한다는건데. 뭐 캔버스에 선 긋는건 아래 예제 참조하고. 버튼 배치도 어떻게 잘 해서(...) 하면 되지 않을까.

+ 단계별로 나눠서 진행하면 된다.
##### 1. 캔버스 위에 절대좌표로 버튼 샘플들을 생성하되, data를 vue를 통해 표현하도록 한다.
##### 2. 데이터 수에 따른 유동적인 버튼 생성을 수행한다. 아마 버튼 노드는..... 유동적으로 생성하려면 vue 객체로는 좀 힘들지도 모름. v-for라는 사기기능이 있는데도 리스트용이라 쓸 수가 없거든... 그래도 우선 한 번 알아보고. 안된다 싶으면 vue 안에서 created 할 때 데이터 read, 리드된 데이터 바탕으로 function 실행시켜서 vue 내부 컴포넌트에 vue component 생성해서 배치, 뭐 이런 순서로 일단 해보자.
* v-for로 된다. 되긴 하는데.... 무슨 현상인지도 알기힘든... 그런 문제가 발생중이다.
* 문제 - v-for로 버튼을 생성하자 페이지에 스크롤이 생겼다. 즉 무언가 컴포넌트가 페이지를 상하로 넓히고 있다. 추가로 다른 페이지에선 스크롤이 안생기는 것으로 보아 v-for만의 문제는 확실하다. - 상위 div를 relative로 두니 해결. 감각적인 감각으론 어떤 문제였는지 대강 예상이 간다. 근데 솔직히 정확하겐 설명 못하겠어.
* 문제 - canvas를 넣는 순간 생기는 문제. canvas가 어떻게 동작하는지는 몰라도 버튼 일부가 더 이상 클릭이 안된다. 즉 정체불명의 무언가가 버튼 위에 생성된다. 이건 뭔데 진짜 ㅋㅋㅋㅋ
* 갑자기 다 잘된다. 뭐지 진짜. 왜 잘되는지 알아야 또 이런 문제가 안터지는데... absolute와 relative의 차이문제인건 분명한데... 커밋 함 합시다 지금. 원인을 모르겠는데 문제가 해결됐으면 우선 해결된 상태를 저장해야지.
##### 3. Mapnode의 좌표를 토대로.... 그림을 그린다. 캔버스를 슬슬 별도 vue로 분리해야할 차래. 아니면.. 맵 신에서 이걸 그리거나. 장단점이 있는데 순리상은 분리가 맞긴 허지.
* 해보니까 부모보다 무조건 자식 created가 나중에 실행되네? 근데 created에서 id값 참조가 안된다. 그래서 map의 read data 동작은 created에서, node의 배치 동작 및 canvas의 draw line 동작은 mounted에서 동작하도록 변경.
* 문제 - canvas의 좌표가 화면상 pixel 좌표랑 따로 노는 것 같다. 이건 Cnavas가 생성된 다음에 css가 적용돼서 생긴 문제. 즉 이미 생긴 캔버스를 늘려서 사이즈를 맞춰서 생긴 문제다. canvas 크기 속성을 html에서 선언해서 해결 완료...
* 참고자료 링크에 있는 vue canvas controlling을 적용해 구현했다. 이거 되니까 겁나 기분좋다.
##### 4. warning 잡고가기.
* 현 상태의 v-for에선 warning이 출력된다. 원인은 key값을 안줬기 때문. 우선 index로 key값을 줬다. 이건 나중에 써먹을 곳도 있다.
##### 5. map data generation
* 시작하기 전에 우선 아직 익숙치 않은거 하나 적음.
    + export let map_model = new CurrentMapModel(); 와 같은 선언은 singletone 객체를 내보낸다.
    + export default class A {} 와 같은 선언은 클래스의 정의를 내보낸다. 즉 데이터 클래스는 이거로 내보내면 됨.
* 아직까지의 계획은 너무 추상적이고, 계획이 추상적이니 pkg 구조도 너무 불합리하다.
* 우선 지도를 그리고 지도에서 게임을 진행하기 위해 데이터가 만족시켜야할 조건들을 적어보자면
    + dungeondata에서 플레이어의 현재 위치를 최소한의 숫자로 표현할 수 있어야 한다.
    + v-for에서 순회 가능한 데이터여야 한다. (2차원 배열 v-for의 경우, 바깥에 x좌표 루프만을 위한 공백 li를 하나 더 두는 것으로 해결하더라.)
    + 최소 부하로 현재 방에서 진행 가능한 방을 구분하고, 현재 방에서 해당 방으로 선을 그을 수 있어야 한다.
    + 해당 데이터를 통해 노드를 맵에 표현하고 선을 그을 수 있어야한다.
    + ㄴ 추가로 각 층에 있는 노드들이 확실하게 구분가는 맵을 그려야한다.
* 원래 계획대로 노드객체를 2차원 배열에 담을 경우. 선은... v-for 3중루프가 들어간다... 이건 좀 어떻게 해야할듯.
* 현재 위치와 클릭으로 선택된 진행방향은 map이 들고있자. 즉, 붉은 선은 map이 긋는다. 다른 노드를 선택하면 선도 다시 긋겠지.
* 다만 저 현재 좌표, 선택 좌표를 vue를 이용해 즉시 반영할 방법이 좀 애매하다. 고작 하나씩 채크되는 값을 위해 배열에 하나하나 boolean필드 넣긴 싫은데.
##### 6. vuex로 임시 데이터를 두고 해당 데이터 참고하기.
* node structure가 가지고있어야할 데이터는 아래와 같다.
* 아니지. index있는데 props로 넘기면 각자 자기인지 채크하면 되는거아녀.
* map generate의 순간이다 드디어. 여기부터 본격적인 게임의 모양세가 나오기 시작한다.
------
#### Data
+ 나중엔 지울 부분. 러프하게 데이터 스트럭쳐를 짜놨는데 절대, 절대, 절대 계획대로 되진 않겠지만 없는거보단 뭐라도 구체적으로 있는게 낫다.
+ js로 객체를 들고있는게 나을듯. 그냥 export해서 싱글톤으로 가자. 인터넷에 vuex export하는거 잘 나와있다.
+ 정의가 다 된 다음엔 필요한 항목을 한정하고 필요없는 v-bind를 전부 걷어낸다.
+ 데이터가 변할 때 animation에 관한 메모. +100 과 같은 문구를 수치 표시 컴포넌트 위에 표시하는게 나을 것 같다...
+ 조금 설계를 다시 해봐야 할 시점같긴 한데. 구체적인 것들을 설계하고나니 그리고있는 디자인이 처음하고 많이 달라진 것 같다.
+ 우선 러프하게 메모리에 들고있을 데이터들 좀 적어보자면.
+ current but static data...? 뭐라 불러야할까 이걸.
    * 가진 캐릭터들의 원래 스텟, 상대중인 몬스터들의 원래 스텟, 들고있는 아이템들의 스팩.
+ current data
    * 플레이어 데이터로 - 자원, 가진 캐릭터들, 현재 캐릭터들의 스텟(돌고있는 스킬 풀 포함), 현재 캐릭터가 들고있는 아이템
    * 던전 데이터로 - 현재 젠 된 던전의 구조(방마다 새로 생성되게 할까 했는데 방 이동과정에서 다 보여주는게 낫다. Scene이 하나 더 늘어나는거지), 상대중인 몬스터들의 현재 스텟.
    * ClickedObject - 현재 클릭된 오브젝트. 대상지정이 필요한 오브젝트 클릭은 bus를 통해 여기로 전달된다. 해당 오브젝트를 홀드하고 다른걸 누르면 두 번째 클릭된 오브젝트를 인풋으로 해당 오브젝트의 이벤트를 처리한다.
+ 위와 같이 적어놓고... js로 export한 객체로 들고있는게 낫다 싶네. 우선 파일을 나눠보자면 아래와 같다.. 좀 하다가 바꾸지 뭐.
    * 플레이어 데이터
        + 가챠용 자원
        + 인벤토리
        + 전체 버프 아이템
    * 던전 데이터 
        + 현재 층수 (1~5)
        + 전체 구조
        + 현재 위치 (이 두 가지만 가지고 다음 진행 가능한 위치를 정할 수 있도록 하는게 좋다고 봄)
    * 대전용 방 데이터
        + 젠 된 몬스터 객체의 배열.
        + 배경 이미지를 깔기 위한 지형정보?
    * 이벤트 씬 용 데이터
        + 이건 이벤트 씬이 어떤 형상인지에 따라 좀 갈릴 것 같다.
    * 대전용 캐릭터 데이터 
        + 사용중인 캐릭터 객체의 배열.
+ 캐릭터의 데이터는 아래와 같다.
    * 이름
    * 등급
    * 직업군
    * 설명이 있어야하는데 이걸 어디서 어떻게 풀어야할지도 관건이다.
    * 원래 HP
    * 원래 ATK
    * 원래 SPD
    * 세 개의 아이템 객체. (UI상 그냥 개수 통일하는걸로)
    * 상태이상
    * 버프 (따로 관리할 것인가 같이 관리할 것인가는 당장은 설계문제로 보인다.)
    * 현재 HP
    * 현재 ATK
    * 현재 SPD
    * 현재 GD
    * 스킬풀 배열 (고정 데이터임)
    * 현재 발동 순서
+ 적 몬스터 데이터는 아래와 같다.
    * 이름
    * 등급 (몹이 사용하는 등급이 높은 아군에게 버프효과, 캐릭터 스킬의 등급이 높은 적에게는 무효 등등의 효과를 위해)
    * 원래 HP
    * 원래 ATK
    * 원래 SPD
    * 상태이상
    * 버프 (따로 관리할 것인가 같이 관리할 것인가는 당장은 설계문제로 보인다.)
    * 현재 HP
    * 현재 ATK
    * 현재 SPD
    * 현재 GD
    * 스킬풀 배열 (고정 데이터임)
    * 현재 발동 순서
+ 종류에 따른 아이템의 데이터를 적고 공통분모를 뽑아내보자.
    * 캐릭터 아이템 데이터는 아래와 같다.
        + 이름
        + 현재 단계 (UI상의 더 삐까번쩍한 처리를 위해. 이하 생략)
        + 설명?
        + 장착된 캐릭터
        + 적용할 효과
    * 재료 아이템 데이터는 아래와 같다.
        + 이름
        + 레어도
        + 설명
        + 아이템 업그레이드 메서드. '맵에서' 클릭하고 아이템을 클릭하면 업그레이드가 될 예정인데. 이 과정에서 업그레이드 가능 아이템에 하이라이트가 표시돼야 한다. 이건 아이템의 정보를 받아와야겠지. 어찌됐건 클릭 이후 뭔가 있어야함.
    * 소비 아이템 데이터는 아래와 같다.
        + 이름
        + 레어도
        + 설명
        + 적용할 효과 메서드. 클릭 후 캐릭터를 선택하면 된다. 클릭만으로 발동하는 전체 대상 효과도 있긴 하것다.
    * 전체 아이템 데이터는 아래와 같다.
        + 이름
        + 설명
        + 적용할 효과 메서드. 아마 발동 타이밍에 따라 bus로 전달받음. 전체 회복같은거도 있고 지속적 스텟상승등도 있기에
+ 적어놓고보니 캐릭터 아이템은 캐릭터의 일부로 생각해도 될 것 같고.. 인벤토리에 있는 아이템들은 클릭 후 뭔가를 누르면 효과를 발동한다는 공통점이 있다. 전체 아이템은 플레이어 데이터로 놓는게 낫지 않을까.
+ 스킬 데이터는 아래와 같다.
    * 이름
    * 효과 설명
    * 스킬을 보유한 캐릭터 객체
    * 클릭시 발동할 메서드. 메서드 안에는 인풋 정의, 즉 적이냐 아군이냐 즉발이냐.
+ 쭉 적고보니 드는 생각이 스킬도 아이템도 다시 누르면 취소하는걸로 해야겠다.
+ 버프, 디버프 데이터는 아래와 같다. 모 게임처럼 전용을 좀 많이 만들고 싶거든. 연계를 위해서 노말 등급, 레어 등급과 연계가 필요한 경우도 생길거고.
    * 이름
    * 턴 수
    * 효과 메서드 (단순 스택은 아무것도 수행 안한다)
------
#### Inputs
+ 당장 떠오르는 인풋들.
+ Main Menu
    * Start.
+ Intro
    * 인트로 다운 무언가를 넣어봄. 그 내용에 따라 달라지겠지만 아마 클릭 한 두 번.
+ Gacha Scene 
    * **정상 Input**
    * 단챠
    * 5연챠
    * Result 캐릭터 클릭 - 다시 눌러 취소, 하단 캐릭터를 눌러 교체.
    * 하단 캐릭터 클릭 - 상단 캐릭터 눌러 교체, 빈슬롯 눌러 위치 변경, 다른 하단 캐릭터 눌러 위치 변경.
    * Go 버튼 - 맵으로 이동
+ Map
    * **정상 Input**
    * 인벤토리에서 업그레이드 아이템 클릭 - 대상 아이템 클릭
    * 인벤토리에서 캐릭터 대상 소비 아이템 클릭 - 캐릭터 클릭 (대상이 틀렸다면 뭔가 표시하긴 해야한다... 붉게 한 번 깜빡이거나.... 이거도 일이다.)
    * 진행 가능한 방 클릭
    * **에러 Input**
    * 캐릭터 클릭 - 아무 이벤트 없음
    * 인벤토리에서 적 대상 소비아이템 클릭 - 아무 이벤트 없음
    * 진행 불가 방 클릭 - 아무 이벤트 없음
+ Map의 구성이 바뀌었기에 아래 Input들은 수정되어야 한다.
+ Battle 시작 전
    * **정상 Input**
    * Battle 클릭
    * 인벤토리에서 소비 아이템 클릭 - 대상 클릭
    * 캐릭터 클릭... 및 스킬 풀 상의 스킬 위치 변경... 을 어떻게 해야할까. 이걸 굳이 해야하냐 근데 프리근혜처럼 마나제로 갈까. 마나회복으로 발동타이밍 조절하면 되지. 그게 알아보기 편한데. 사실 동작 원리는 같은데 알아보기만 더 쉬워지는거라 생각할 수 있지 않나. 다음 페이즈에서 고민.
    * **에러 Input**
    * 인벤토리에서 업그레이드 아이템 클릭 - 아무 이벤트 없음
    * 다운된 캐릭터 클릭. - 아무 이벤트 없음
+ Battle 시작 후 2초 쾅 한 뒤.
    * **정상 Input**
    * 드랍창에서 아이템 클릭 - 드랍창 빈 칸 클릭, 드랍창 아이템 클릭, 아이템 창 빈 칸 클릭, 아이템 창 아이템 클릭
    * 아이템 창 아이템 클릭 - 드랍창 빈 칸 클릭, 드랍창 아이템 클릭, 아이템 창 빈 칸 클릭, 아이템 창 아이템 클릭.
    * OK 버튼 클릭 (Map 또는 스테이지 따라서 Gacha로 넘어감. 다만 보스전 클리어 후면 사이에 짧은 뭐 정도는 있어야.)
+ Event Scene
    * 선택지 뜨고 선택하자 그냥. 그거말고 인풋이란 없.... 진 않을수도 있다.    
------
#### Emits and on
+ 각 판넬이 표시할 정보와 emit할 결과값들을 쭉 적어보자.
    * GachaPanel 
        + main : 표시는 가챠용 자원, 픽업. emit은 돈쓰는거.
        + result : 표시는 가챠 결과, 가챠용 자원, 선택된 캐릭터 존재 여부. emit은 character 선택, 완료 클릭 시 이벤트 발생(선택된 캐릭터 없으면 완료 불가).
------
#### popup
+ 플레이어의 확인이 필요한 동작, 혹은 불가능한 동작을 할 시 짜증나지 않을 수준의 적절한 수준의 팝업을 띄워줘야한다.
+ 개발단계가 어느정도 정리가 돼야 수행할 작업이지만 일단 항목만 미리 적어놓음.
    * 일단 가챠에는 무조건 확인 팝업이 있어야함. 이는 확인이 필요해서가 아니라 손맛을 위해서이다.
------
#### Issues
+ Webpack config의 alias 미작동 문제 - 짜증이 나는 것을 넘어 분노에 이르고있다. webpack.base.conf.js에 열심히 설정을 넣어줬지만 전혀, 아무런 영향도 없다. 우선 그냥... ../../../../../ 하자... 참기 힘들어도. 아니 근데 볼 때마다 에바핫바오다이바 3절로 나오는데 좀 멘탈 될 때 꼭 다시 고치자.
+ v-if의 컴포넌트 초기화 문제. 어느정도 예상하긴 했는데 v-if는 false가 되는 순간 객체를 지워버린다. 즉 생각했던 것 처럼 객체를 겹쳐놓고 쓰지는 못한다. 맵 제네레이트등의 초기화 동작을 컴포넌트에서 하면 안된다 이 말이지. 애초에 구조상 뭐가 더 바람직한지도 애매한 부분이다. 어쨌건. 데이터 초기화 동작 등은 컴포넌트 밖으로 빼자.
------
## 참고할 자료들
+ css에서 버튼 위치 absolute로 잡기 - https://stackoverflow.com/questions/18640503/how-to-position-the-button-exactly-in-css
+ webpack으로 구현하는 vue 프로젝트를 위한 BoilerPlate. vue cli 쓸 거지만 참고할 부분도 있지 않을까. - https://github.com/yamoo9/vue-simple
+ 이건 우리랑은 상관없겠다만 규모가 큰 프로젝트용 Boilerplate - https://github.com/yamoo9/vue-full/blob/master/docs/README.md
+ Flex로 레이아웃을 만들어보자. - https://poiemaweb.com/css3-flexbox
+ 여러 애니메이션. 나중에 버튼같은데 적용하면 좋을 것 같은게 꽤 보임. - http://rwdb.kr/interestedeffects/
+ zoom in. 반대로 하면 zoom out이지. - https://www.youtube.com/watch?v=EHmoLmYQ480
+ 로딩용 텍스트 css를 찾았다 - https://freefrontend.com/css-text-animations/
+ 맵을 그리는데 필요한 기술 - http://jsfiddle.net/m1erickson/86f4C/
+ 캔버스 사용법? - http://www.informit.com/articles/article.aspx?p=1903884&seqNum=8
+ 툴팁. 아마도... 많이 필요하다. 상당히. - https://codepen.io/electricalbah/pen/eJRLVd
+ 웹팩 import 경로 줄이기. 개고생을 상당히 줄여줄듯. - http://guswnsxodlf.github.io/path-alias-in-webpack-and-jest
+ vue로 canvas 컨트롤하기 - https://alligator.io/vuejs/vue-html5-canvas/
+ canvas에 버튼 겹치는 부분만 따로 때놓은 예제. 간단하니 시작점으로 생각하기 좋아보인다... 근데 absolute로 포지셔닝하면 사실 캔버스고 머고 겹치는게 특별한 건 아니네... - https://jsfiddle.net/n2EYw/398/
+ 일단 선 교차 검사는 여기. - https://tibyte.kr/288
+ 웹팩 데이터 클래스 관련. 웹팩 모듈은 강제 싱글톤이다. 더 좋은 자료도 많지 않을까? 아직은 잘 모르겠다 - https://stackoverflow.com/questions/49569061/is-singleton-guaranteed-to-be-preserved-during-webpack-or-rollup-module-bundling
+ 흠... 일단 뷰 안에 컴포넌트를 릴레이티브하게 넣는 방법같다. - https://stackoverflow.com/questions/49983893/position-coordinates-of-an-element-related-to-viewport-not-relative-via-js
+ 라인 스타일 - https://developer.mozilla.org/ko/docs/Web/HTML/Canvas/Tutorial/Applying_styles_and_colors
+ vuex 따라해보자 - http://labs.brandi.co.kr/2018/12/13/kangww.html
+ 동적 임포트. 이번에도, 앞으로도 쓸 일은 없을 것 같다만. - https://medium.com/front-end-weekly/webpack-and-dynamic-imports-doing-it-right-72549ff49234