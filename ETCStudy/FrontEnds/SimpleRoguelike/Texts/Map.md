#### Map
+ 맵의 형태부터 정해야한다.
+ 아까 대충 그려보니 내가 원래 구상하던 거에 선 좀 더 긋는다고 뭐가 더 나아지진 않을 것 같아 보이더라. 다만 슬더스 식 취사선택형 맵은 그대로 갈라고.
+ 최대한 상상력을 자극할 수 있도록 지도의 형태를 보이면서도. 그러면서도 게임 요소로서 재밌어보여야해. 우선 진행 라인 자체의 디자인은 능력되면 전자기판같은 느낌의 디자인은 어떨까. 
+ 각 방이 뭘 의미하는지도 좀 생각해봐야한다. 그래야 지도의 스케일이 정해지고 좀 더 섬세하게 가득찬 느낌의 세계를 구상할 수 있으니까. 이건 세계관과 직결이다.
+ 지금 최대 문제점은 이쁘게 만들려면 한 층당 진행 방 수가 8개가 한계라는거지. 5스테이지까지 있긴 하지만 못해도 70층 구성은 해야된...다. 아마?
+ 스크롤 바 있는 캔버스를 해도 문제인게 버튼하고 캔버스는 따로여.... 
+ **미션식이다.**
+ 왜 이걸 진즉에 생각 못했지.
+ 이거라면 맵상 표시되는 진행 방 수는 6, 7, 7, 8, 9 개까지면 충분하다. 아니 오히려 그 이상이면 난잡하다.
+ 한 방에서 전투 내지는 이벤트, 퍼즐 등을 세 번씩 벌이게 만들어버리면 된다. 방의 구성은 마우스 올리면 팝업으로 뜨는거지.
+ 이거면 그냥 맵 진행이 합리적일 뿐만 아니라.... 신박한데다 UI만 예쁘게 만들면 재밌기까지 하다. 방 하나하나의 의미는 더욱 깊어지고 게임 제작자가 유저에게 내줄 수 있는 숙제도 더 커진다. 뿐만 아니라 이 시스템을 이용하는 룸 패턴도 만들 수 있다.
+ 방 하나하나는 그러니까, 뚫어야하는 하나하나의 기지, 초소, 요세, 포인트인거다. 그걸 뚫는 과정을 전투 세 번 내지는 전투 이벤트 전투 등등으로 세분화 하는거고. 방마다 뚜렷한 개성도 생긴다. 특정 초소가 출현하면 만나게 되는 네임드같은 패턴까지 가능하다 이건. 보상은? 전체아이템이지.
+ 슬더스 장점 융화형 미션식 로그라이크 맵의 라인 생성 
    * 포인트(층)은 스테이지에 따라 6 ~ 8개까지 늘어난다. (보스 포함, 1 = 6/ 2, 3 = 7 / 4, 5 = 8 이 느낌도 나고 공식도 하나로 정리되는듯.)
    * 각 층(수평상태)엔 3~5개의 방이 있다.
    * 윗 층, 아랫층에 상관없이 진행 경로는 방이 더 많은 쪽에서 생성한다.
    * 경로의 수는 방이 더 많은 쪽의 방 수를 n으로 놓으면 n ~ n + 1 이다. 여기서 각 케이스에 대해 경우를 적고 합당한 공식을 유추해보자.
    * n 대 n' 인 경우, n개의 라인을 놓고 random(n)으로 골라진 블록에서 자신의 위치 +- 1로 라인 하나 더 생성.
    * n 대 n'-1 인 경우, rondom(n) 으로 방 하나를 뽑고 나머지 방들로 n'-1과 1 대 1로 이음. 뽑힌 방은 자신의 원래 위치 or 원래 위치 -1에 이음 (이 떄 n이면 원래 위치 -1만 가능). 
    * 이 때 선을 그어선 안되는 위치는. n이 n'과 이어진 경우 n+1과 n-1, n이 n'-1과 이어진 경우 n-1과 n'. 앞에건 2 차이가 나서 이어질 일이 없지만 뒤에건... 한 번에 거르려면 고민 좀 해야한다.
    * n 대 n'-2 인 경우, 는 사실 5 대 3밖에 없다. random(n)을 두 번 돌려 방 두 개를 뽑고 나머지를 1 대 1 매핑한다.
    * 1차 구조. (보스방으로 이어지는 경우는 별도 계산)
    1. 앞의 노드 수, 뒤의 노드 수 n과 m에 대해, n > m을 검사해 검사 function에 큰 쪽 작은 쪽, 어느쪽이 앞쪽인지를 넘긴다. 큰 쪽을 n이라 한다.
    2. n - m 만큼 random으로 n에서 노드를 뽑는다.
    3. 해당 노드를 제외한 노드들을 m에 순서대로 1 대 1 연결한다. 이 때 연결된 선분의 좌표는 앞쪽 노드 객체에 저장.
    * 이후 선을 랜덤으로 생성하며 벡터를 사용한 선분 교차검사를 한다. n이 앞쪽이라면 자기자신의 위 아래, n이 뒤쪽이라면 연결 대상의 위 아래 노드에 저장된 선분만 비교하면 된다.
    4. 우선 첫 랜덤 생성 대상은 뽑힌 n-m의 노드들. 이후 랜덤으로 1 ~ 2개의 노드를 더 선택해서 선분을 랜덤으로 긋고 위 아래와의 중첩여부를 비교한다. 맨 끝 노드들과 중앙 노드들에 적용되는 공식이 달라진다. 또한 같은 선분을 두 번 생성하지 않도록 한다. 이 부분은 유두리있게.
    
+ 슬더스 장점 융화형 미션식 로그라이크 맵의 방 생성
    * 어떤 방이 어느즈음에서 얼마나 나올지가 상당히 중요하다.
    * 중간엔 무조건 힐 지점 하나 넣는다 치고. 문제는 나머지의 배분인데. 일반 요세, 정예 요세, 이벤트 지점 등으로 나눈다 치고. 앞에 뭐가 있느냐에 따라 뒤에 뭐가 있을지의 확률이 좀 달라져야할 것 같음. 막말로 정예 2연타같은건 나오면 안되니까.
    1. 길이가 입력되면 마지막 층을 제외하고 나머지 층에 3~5개의 방 데이터 객체를 생성한다.
    2. type 힐을 우선 밀어넣는다. n/2(올림) 지점이다.
    3. 다음 마지막 1개짜리 노드를 type 보스로 한다.
    4. 여기서 각 포인트를 잇는 메서드를 실행시킨다.
    5. 다음 type 정예를 밀어넣고 정예의 다음 노드가 비어있다면 정예 다음 노드 전용의 확률로 이어진 노드들을 초기화해준다. 힐 5 일반 2 이벤 3.
    6. 나머지 빈 칸에 대해 확률계산을 수행한다. 아마 비율은 이벤트 노드 4 일반노드 4 힐노드 2 정도일 것. 던전 구성상 힐은 온전히 힐이 아니니까 그 정도는 줘도 된다고 생각함. 해보면 또 조정이 필요하겠지만 우선은 그 이상은 뭐 플레이어 운에 맡기자.
+ 요세의 내부젠은 뒷통수 좀 칠 수 있게 규격으로 합시다. 스테이지당 종류별로 규격화된 요세 패턴이 몇 개씩 있으면 예상도 좀 해볼 수 있을거고 머리좀 굴려야할 것.
    
+ 슬더스 장점 융화형 미션식 로그라이크 맵의 드로잉
    * 일단 진행 길이 수 만큼의 화면의 y축의 픽셀을 column으로 나눈다. 최소값, 최대값을 가지고 픽셀 배분하되 보스방의 위치는 픽스다.
    * 각 column의 픽셀을 해당 column에 존재하는 노드 수로 최소값, 최대값을 두고 나눈다. 노드가 존재 가능한 위치를 어느정도 이쁜 선에서 랜덤으로 만들기 위함.
    * 나뉜 칸 안에서 노드의 좌표를 찍는다. 버튼의 라운드를 50%로 두고 보더도 좀 두껍게 둬서 이쁜 원형 버튼으로 만들거임. 중앙 값을 구하고 캔버스에 해당 좌표에서 이어진 노드로 선을 그음.

+ 클릭 동작
    * clickable은 다음 노드 리스트에 존재하는 노드들로 한정된다. 나머지는 그냥 눌러도 아무 표시도 되지 않는다.
    * 다음 노드의 배열상 좌표를 가지고 해당 노드의 clickable을 true로 한다. 다음 노드가 선택되면.... 현재 노드에 다음 노드가 선택되었음을 인식시켜야 선을 긋는다...
    * 생성된 line의 데이터는 전 노드가 들고있다. 클릭 가능한 노드가 클릭될 시, 우선 가진 선 중에 기존 붉은 선이 있다면 검은색으로 바로 바꾸고 새로 들어온 좌표까지 붉은 선을 쭉 그어준다. 이게 데이터를 얼마나 먹는질 모르겠네.
    * Dive 이후엔 한 번 표시된 붉은 선의 데이터는 리프래시 하지 말자. 지금까지의 경로를 보여주는거도 나쁘진 않을 것 같거든.

+ 대충 단순 맵에 필요한 데이터를 정리하자면....
    1. 각 row의 데이터 길이가 다른 방 데이터 2차원 배열이 있다.
    2. 방 데이터는 다음의 데이터를 가지고 있다. 이어지는 노드의 배열상 좌표, 내 좌표 x, y. 선택된  다음 노드(기본 null 상태. null 검사 가능하니까 이게 또 좋네). 자신의 구조.
    3. 층수는 GameData가 들고있다는다. 유저의 위치는... 게임 객체가 들고있어야 할 것 같기도 하고 맵 객체가 들고있어야할 것 같기도 하고.. 유저 객체가 들고있는게 맞을듯. 유저의 좌표니까.

+ 맵 계획은 완료.
+ 문제는 컴포넌트에 개입하는 과정이 데이터 저장과 vue에서 이를 해석하는 과정을 통해 이루어져야한다는건데. 뭐 캔버스에 선 긋는건 아래 예제 참조하고. 버튼 배치도 어떻게 잘 해서(...) 하면 되지 않을까.

+ 단계별로 나눠서 진행하면 된다.
##### 1. 캔버스 위에 절대좌표로 버튼 샘플들을 생성하되, data를 vue를 통해 표현하도록 한다.
##### 2. 데이터 수에 따른 유동적인 버튼 생성을 수행한다. 아마 버튼 노드는..... 유동적으로 생성하려면 vue 객체로는 좀 힘들지도 모름. v-for라는 사기기능이 있는데도 리스트용이라 쓸 수가 없거든... 그래도 우선 한 번 알아보고. 안된다 싶으면 vue 안에서 created 할 때 데이터 read, 리드된 데이터 바탕으로 function 실행시켜서 vue 내부 컴포넌트에 vue component 생성해서 배치, 뭐 이런 순서로 일단 해보자.
* v-for로 된다. 되긴 하는데.... 무슨 현상인지도 알기힘든... 그런 문제가 발생중이다.
* 문제 - v-for로 버튼을 생성하자 페이지에 스크롤이 생겼다. 즉 무언가 컴포넌트가 페이지를 상하로 넓히고 있다. 추가로 다른 페이지에선 스크롤이 안생기는 것으로 보아 v-for만의 문제는 확실하다. - 상위 div를 relative로 두니 해결. 감각적인 감각으론 어떤 문제였는지 대강 예상이 간다. 근데 솔직히 정확하겐 설명 못하겠어.
* 문제 - canvas를 넣는 순간 생기는 문제. canvas가 어떻게 동작하는지는 몰라도 버튼 일부가 더 이상 클릭이 안된다. 즉 정체불명의 무언가가 버튼 위에 생성된다. 이건 뭔데 진짜 ㅋㅋㅋㅋ
* 갑자기 다 잘된다. 뭐지 진짜. 왜 잘되는지 알아야 또 이런 문제가 안터지는데... absolute와 relative의 차이문제인건 분명한데... 커밋 함 합시다 지금. 원인을 모르겠는데 문제가 해결됐으면 우선 해결된 상태를 저장해야지.
##### 3. Mapnode의 좌표를 토대로.... 그림을 그린다. 캔버스를 슬슬 별도 vue로 분리해야할 차래. 아니면.. 맵 신에서 이걸 그리거나. 장단점이 있는데 순리상은 분리가 맞긴 허지.
* 해보니까 부모보다 무조건 자식 created가 나중에 실행되네? 근데 created에서 id값 참조가 안된다. 그래서 map의 read data 동작은 created에서, node의 배치 동작 및 canvas의 draw line 동작은 mounted에서 동작하도록 변경.
* 문제 - canvas의 좌표가 화면상 pixel 좌표랑 따로 노는 것 같다. 이건 Cnavas가 생성된 다음에 css가 적용돼서 생긴 문제. 즉 이미 생긴 캔버스를 늘려서 사이즈를 맞춰서 생긴 문제다. canvas 크기 속성을 html에서 선언해서 해결 완료...
* 참고자료 링크에 있는 vue canvas controlling을 적용해 구현했다. 이거 되니까 겁나 기분좋다.
##### 4. warning 잡고가기.
* 현 상태의 v-for에선 warning이 출력된다. 원인은 key값을 안줬기 때문. 우선 index로 key값을 줬다. 이건 나중에 써먹을 곳도 있다.
##### 5. map data generation
* 시작하기 전에 우선 아직 익숙치 않은거 하나 적음.
    + export let map_model = new CurrentMapModel(); 와 같은 선언은 singletone 객체를 내보낸다.
    + export default class A {} 와 같은 선언은 클래스의 정의를 내보낸다. 즉 데이터 클래스는 이거로 내보내면 됨.
* 아직까지의 계획은 너무 추상적이고, 계획이 추상적이니 pkg 구조도 너무 불합리하다.
* 우선 지도를 그리고 지도에서 게임을 진행하기 위해 데이터가 만족시켜야할 조건들을 적어보자면
    + dungeondata에서 플레이어의 현재 위치를 최소한의 숫자로 표현할 수 있어야 한다.
    + v-for에서 순회 가능한 데이터여야 한다. (2차원 배열 v-for의 경우, 바깥에 x좌표 루프만을 위한 공백 li를 하나 더 두는 것으로 해결하더라.)
    + 최소 부하로 현재 방에서 진행 가능한 방을 구분하고, 현재 방에서 해당 방으로 선을 그을 수 있어야 한다.
    + 해당 데이터를 통해 노드를 맵에 표현하고 선을 그을 수 있어야한다.
    + ㄴ 추가로 각 층에 있는 노드들이 확실하게 구분가는 맵을 그려야한다.
* 원래 계획대로 노드객체를 2차원 배열에 담을 경우. 선은... v-for 3중루프가 들어간다... 이건 좀 어떻게 해야할듯.
##### 6. vuex로 임시 데이터를 두고 해당 데이터 참고하기.
* node structure가 가지고있어야할 데이터는 아래와 같다.
* 아니지. index있는데 props로 넘기면 각자 자기인지 채크하면 되는거아녀.
* map generate의 순간이다 드디어. 여기부터 본격적인 게임의 모양세가 나오기 시작한다.
##### 7. 던전이 생성한 데이터로 맵노드 뿌리기.
* node의 랜덤 포지션 값은 버튼 크기의 3분에 1로 줌.
* v-for 2중루프를 사용해 뿌려줬는데 상당히 만족스럽게 나왔다.
* 생성 타이밍은 추후에 조정해야겠지만 꽤 그럴싸한 결과물이 나왔다.
##### 8. 라인 그리기.
* 붉은 라인은 우선 신경쓰지 말고 검은색으로 그려보자. 다만 붉은 색이 될 경우 캔버스에 바로 반영됨을 잊지말자. 참조한 예시에서도 반응형 캔버스 드로우 잘 하고있으니 어렵진 않을 듯.
* 위에 계획한 대로 코드를 짰더니 일단 완성됐다. 다만 생성에 시간이 좀 걸리는구만.
##### 9. 진행 및 글릭 가능 여부에 따른 반응형 맵 완성 
* MapModel의 상태에 따라 반응형으로 맵을 그려야한다. 인프라 충분히 갖추어져서 쉽지 않을까?
* 허나 이건, 이제 슬슬 코앞으로 다가온 게임 전체 진행 흐름을 어느정도 완성시킨 뒤에 구현해야할 부분 같다.
##### 10. 맵이 여러 갈래의 분리된 길로 생성되는 건에 대해
* 하기 절차를 통해 맵의 길들을 전부 이어줄 생각이다. 아래 과정만 가지고 추가 교차로를 생성할 경우, 이 또한 리스크가 크기에 보조 과정으로 한다. 맵 좀 귀찮게 만들어야지 뭐....
1. 좌 상단에서 시작. 현위치, 왔던 길을 놓고 수행
2. 진행 가능 노드 중 맨 우측 노드로 이동
3. 한 칸 앞의 왔던길의 오른쪽 노드가 현 위치로 진행 가능하다면 해당 노드로 이동을 while로 반복. 아니라면 2로 진행
4. 해당 과정에서 배열로 진행했던 y축 데이터를 전부 들고있으면 최 외곽 경로가 나옴.
5. 마지막에 도달한 곳이 마지막 층의 y측 오른쪽 끝이 아니라면 진행경로+1 (맨 우측 길이 직선일 경우, 해당 길에서 뻗어나와야 하기 때문)에서 랜덤으로 1~2개 노드를 선택해 길을 이어준다.
6. 이 과정을 끝에 도달할 때까지 반복.
##### 11. 다음, 맵이 전부 이어진 후에도 외길이 나오는 사태에 대해.
* 위 철자를 전부 수행해서 기본 갈래길이 들어가고, 모든 맵이 다 이어진 후에도 외길을 없애기 위해 다시 for문을 돌려야한다...
* 이거 처음부터 알고리즘 다시 생각할까 싶기도 하네. 처음 구축할 때 외길을 채크하면서 가는거지... 
* 자 우선 처음 방식대로 길을 이으면서 외길을 채크함.
* x+1의 노드에서 자신에게 이어지는 노드가 하나뿐이며 앞 노드 데이터에서도 그랬다면 이를 채크함. 앞노드에서 그랬는지는 길이 5짜리 배열로 들고있자.
1. 배제노드의 선을 그을 때 한 가닥만 이어진 곳이 결정된다. 배제노드에서 선이 이어지지 않은 곳은 이어진 선이 한 가닥이라고 볼 수 있다.
2. 자신에게 이어진 선이 외길이였는가 채크하는 방법. 직전 저장된 배열에서 해당 노드를 채크해보면 알 수 있다. 숫자로 넣고 ++로 가자.
3. 만약 직전까지 수치가 3 이상이면 확정으로 해당 노드에서 선을 긋도록 한다.
4. 선을 긋는 타이밍은 connected latter 이후.
##### 맵 그리기 완성. 원래라면 맵만들기의 다음 순서는 이벤트의 배분이다. 우선 다른 부분을 더 진행해야하는지 살펴보고 진행 여부를 정하자.
